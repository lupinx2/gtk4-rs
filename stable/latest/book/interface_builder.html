<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Interface Builder - GUI development with Rust and GTK 4</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">1.</strong> Installation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="installation_linux.html"><strong aria-hidden="true">1.1.</strong> Linux</a></li><li class="chapter-item expanded "><a href="installation_macos.html"><strong aria-hidden="true">1.2.</strong> macOS</a></li><li class="chapter-item expanded "><a href="installation_windows.html"><strong aria-hidden="true">1.3.</strong> Windows</a></li></ol></li><li class="chapter-item expanded "><a href="project_setup.html"><strong aria-hidden="true">2.</strong> Project Setup</a></li><li class="chapter-item expanded "><a href="hello_world.html"><strong aria-hidden="true">3.</strong> Hello World!</a></li><li class="chapter-item expanded "><a href="widgets.html"><strong aria-hidden="true">4.</strong> Widgets</a></li><li class="chapter-item expanded "><a href="gobject_concepts.html"><strong aria-hidden="true">5.</strong> GObject Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="gobject_memory_management.html"><strong aria-hidden="true">5.1.</strong> Memory Management</a></li><li class="chapter-item expanded "><a href="gobject_subclassing.html"><strong aria-hidden="true">5.2.</strong> Subclassing</a></li><li class="chapter-item expanded "><a href="gobject_values.html"><strong aria-hidden="true">5.3.</strong> Generic Values</a></li><li class="chapter-item expanded "><a href="gobject_properties.html"><strong aria-hidden="true">5.4.</strong> Properties</a></li><li class="chapter-item expanded "><a href="gobject_signals.html"><strong aria-hidden="true">5.5.</strong> Signals</a></li></ol></li><li class="chapter-item expanded "><a href="main_event_loop.html"><strong aria-hidden="true">6.</strong> The Main Event Loop</a></li><li class="chapter-item expanded "><a href="settings.html"><strong aria-hidden="true">7.</strong> Settings</a></li><li class="chapter-item expanded "><a href="saving_window_state.html"><strong aria-hidden="true">8.</strong> Saving Window State</a></li><li class="chapter-item expanded "><a href="list_widgets.html"><strong aria-hidden="true">9.</strong> List Widgets</a></li><li class="chapter-item expanded "><a href="interface_builder.html" class="active"><strong aria-hidden="true">10.</strong> Interface Builder</a></li><li class="chapter-item expanded "><a href="todo_app_1.html"><strong aria-hidden="true">11.</strong> Building a Simple To-Do App</a></li><li class="chapter-item expanded "><a href="actions.html"><strong aria-hidden="true">12.</strong> Actions</a></li><li class="chapter-item expanded "><a href="todo_app_2.html"><strong aria-hidden="true">13.</strong> Manipulating State of To-Do App</a></li><li class="chapter-item expanded "><a href="css.html"><strong aria-hidden="true">14.</strong> CSS</a></li><li class="chapter-item expanded "><a href="resources.html"><strong aria-hidden="true">15.</strong> Resources</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.</strong> Internationalization</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">17.</strong> Accessibility</div></li><li class="chapter-item expanded affix "><li class="part-title">Useful Libraries</li><li class="chapter-item expanded "><div><strong aria-hidden="true">18.</strong> Relm4</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">19.</strong> GStreamer</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">20.</strong> Adwaita</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">21.</strong> SourceView</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">22.</strong> Shumate</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">23.</strong> WebKitGTK</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">24.</strong> Zbus and Ashpd</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">25.</strong> Librsvg</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">GUI development with Rust and GTK 4</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/gtk-rs/gtk4-rs/tree/master/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="interface-builder"><a class="header" href="#interface-builder">Interface Builder</a></h1>
<h2 id="gtk-builder"><a class="header" href="#gtk-builder">GTK Builder</a></h2>
<p>Until now, whenever we constructed pre-defined widgets we relied on the <a href="https://rust-unofficial.github.io/patterns/patterns/creational/builder.html">builder pattern</a>.
As a reminder, that is how we used it in our trusty &quot;Hello World!&quot; app.</p>
<p><span class="filename">Filename: listings/hello_world/3/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground">use gtk::prelude::*;
use gtk::{Application, ApplicationWindow, Button};

fn main() {
    // Create a new application
    let app = Application::builder()
        .application_id(&quot;org.gtk-rs.example&quot;)
        .build();

    // Connect to &quot;activate&quot; signal of `app`
    app.connect_activate(build_ui);

    // Run the application
    app.run();
}

fn build_ui(app: &amp;Application) {
    // Create a button with label and margins
    let button = Button::builder()
        .label(&quot;Press me!&quot;)
        .margin_top(12)
        .margin_bottom(12)
        .margin_start(12)
        .margin_end(12)
        .build();

    // Connect to &quot;clicked&quot; signal of `button`
    button.connect_clicked(move |button| {
        // Set the label to &quot;Hello World!&quot; after the button has been clicked on
        button.set_label(&quot;Hello World!&quot;);
    });

    // Create a window
    let window = ApplicationWindow::builder()
        .application(app)
        .title(&quot;My GTK App&quot;)
        .child(&amp;button)
        .build();

    // Present window
    window.present();
}</code></pre>
<p>Creating widgets directly from code is perfectly fine.
However, with most toolkits you can describe your user interface with a markup language and GTK is no exception here.
For example the following <code>xml</code> snippet describes the window widget of the &quot;Hello World!&quot; app. </p>
<p><span class="filename">Filename: listings/interface_builder/1/window.ui</span></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;interface&gt;
  &lt;object class=&quot;GtkApplicationWindow&quot; id=&quot;window&quot;&gt;
    &lt;property name=&quot;title&quot;&gt;My GTK App&lt;/property&gt;
    &lt;child&gt;
      &lt;object class=&quot;GtkButton&quot; id=&quot;button&quot;&gt;
        &lt;property name=&quot;label&quot;&gt;Press me!&lt;/property&gt;
        &lt;property name=&quot;margin-top&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-bottom&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-start&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-end&quot;&gt;12&lt;/property&gt;  
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/object&gt;
&lt;/interface&gt;
</code></pre>
<p>The most outer tag always has to be the <code>&lt;interface&gt;</code>.
Then you start listing the elements you want to describe.
In our case, we want to have a <code>gtk::ApplicationWindow</code>.
These <code>xml</code> files are independent of the programming language, which is why the classes have the original names.
Luckily, they all convert like this: <code>gtk::ApplicationWindow</code> → <code>GtkApplicationWindow</code>.
We want to access the window later on, so we also give it an <code>id</code>.
Then we can specify properties which are specified <a href="https://docs.gtk.org/gtk4/class.ApplicationWindow.html">here</a> for <code>ApplicationWindow</code>.
Since <code>ApplicationWindow</code> can contain other widgets we use the <code>&lt;child&gt;</code> tag to add a <code>Button</code>.</p>
<p>To instantiate the widgets described by the <code>xml</code> files we use <a href="../docs/gtk4/struct.Builder.html"><code>gtk::Builder</code></a>.
All widgets that can be described that way can be found <a href="../docs/gtk4/prelude/trait.BuildableExt.html#implementors-1">here</a></p>
<blockquote>
<p>Puh, yet another builder? Let us summarize what we have so far:</p>
<ul>
<li><a href="https://flathub.org/apps/details/org.gnome.Builder">GNOME Builder</a>, an IDE used to create GNOME apps, </li>
<li><a href="https://rust-unofficial.github.io/patterns/patterns/creational/builder.html">builder pattern</a>, a design pattern used to create objects with many optional parameters and</li>
<li><a href="../docs/gtk4/struct.Builder.html"><code>gtk::Builder</code></a>, the interface builder which creates widgets from <code>xml</code> files.</li>
</ul>
<p>That was it with the builders.
Promised!</p>
</blockquote>
<p>This is how it then looks in practice:</p>
<p><span class="filename">Filename: listings/interface_builder/1/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow, Button};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span>fn build_ui(app: &amp;Application) {
    // Init `gtk::Builder` from file
    let builder = gtk::Builder::from_string(include_str!(&quot;window.ui&quot;));

    // Get window and button from `gtk::Builder`
    let window: ApplicationWindow = builder
        .object(&quot;window&quot;)
        .expect(&quot;Could not get object `window` from builder.&quot;);
    let button: Button = builder
        .object(&quot;button&quot;)
        .expect(&quot;Could not get object `button` from builder.&quot;);

    // Set application
    window.set_application(Some(app));

    // Connect to &quot;clicked&quot; signal
    button.connect_clicked(move |button| {
        // Set the label to &quot;Hello World!&quot; after the button has been clicked on
        button.set_label(&quot;Hello World!&quot;);
    });

    // Add button
    window.set_child(Some(&amp;button));
    window.present();
}</code></pre>
<p>This is a bit disappointing.
Even though we have already described the UI in the markup file, the amount of code is still pretty much the same.
There are still cases where it is valuable to know of the existence of <code>gtk::Builder</code>.
We will see for example that <a href="../docs/gtk4/struct.ShortcutsWindow.html"><code>ShortcutsWindow</code></a> is quite a bit easier to instantiate that way.</p>
<p>At least we did not lose any flexibility by using <code>gtk::Builder</code>.
It is for example still possible to refer to custom widgets such as this bare-bones <code>CustomButton</code>.</p>
<p><span class="filename">Filename: listings/interface_builder/2/custom_button/imp.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">
</span>// Object holding the state
#[derive(Default)]
pub struct CustomButton;

// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for CustomButton {
    const NAME: &amp;'static str = &quot;MyGtkAppCustomButton&quot;;
    type Type = super::CustomButton;
    type ParentType = gtk::Button;
}
<span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for CustomButton {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for CustomButton {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all buttons
</span><span class="boring">impl ButtonImpl for CustomButton {}</span></code></pre>
<p>Within the <code>xml</code> file we reference the widget with the <code>NAME</code> we gave it in <code>imp.rs</code>.</p>
<p><span class="filename">Filename: listings/interface_builder/3/window/window.ui</span></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;interface&gt;
  &lt;object class=&quot;GtkApplicationWindow&quot; id=&quot;window&quot;&gt;
    &lt;property name=&quot;title&quot;&gt;My GTK App&lt;/property&gt;
    &lt;child&gt;
      &lt;object class=&quot;MyGtkAppCustomButton&quot; id=&quot;button&quot;&gt;
        &lt;property name=&quot;label&quot;&gt;Press me!&lt;/property&gt;
        &lt;property name=&quot;margin-top&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-bottom&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-start&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-end&quot;&gt;12&lt;/property&gt;  
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/object&gt;
&lt;/interface&gt;
</code></pre>
<p>We also have to make sure to register the custom widget before it is used by the interface builder.</p>
<p><span class="filename">Filename: listings/interface_builder/2/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod custom_button;
</span><span class="boring">
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::{Application, ApplicationWindow};
</span><span class="boring">
</span><span class="boring">use custom_button::CustomButton;
</span><span class="boring">
</span>fn main() {
    // Create a new application
    let app = Application::builder()
        .application_id(&quot;org.gtk-rs.example&quot;)
        .build();

    // Connect to &quot;activate&quot; signal
    app.connect_activate(build_ui);

    // Register custom button
    CustomButton::static_type();

    // Run the application
    app.run();
}
<span class="boring">
</span><span class="boring">fn build_ui(app: &amp;Application) {
</span><span class="boring">    // Init `gtk::Builder` from file
</span><span class="boring">    let builder = gtk::Builder::from_string(include_str!(&quot;window.ui&quot;));
</span><span class="boring">
</span><span class="boring">    // Get window and button from `gtk::Builder`
</span><span class="boring">    let window: ApplicationWindow = builder
</span><span class="boring">        .object(&quot;window&quot;)
</span><span class="boring">        .expect(&quot;Could not get object `window` from builder.&quot;);
</span><span class="boring">    let button: CustomButton = builder
</span><span class="boring">        .object(&quot;button&quot;)
</span><span class="boring">        .expect(&quot;Could not get object `button` from builder.&quot;);
</span><span class="boring">
</span><span class="boring">    // Set application
</span><span class="boring">    window.set_application(Some(app));
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;clicked&quot; signal
</span><span class="boring">    button.connect_clicked(move |button| {
</span><span class="boring">        // Set the label to &quot;Hello World!&quot; after the button has been clicked on
</span><span class="boring">        button.set_label(&quot;Hello World!&quot;);
</span><span class="boring">    });
</span><span class="boring">
</span><span class="boring">    // Add button
</span><span class="boring">    window.set_child(Some(&amp;button));
</span><span class="boring">    window.present();
</span><span class="boring">}</span></code></pre>
<h2 id="composite-templates"><a class="header" href="#composite-templates">Composite Templates</a></h2>
<p>The actual reason why we devote a whole chapter to the interface builder is the existence of composite templates.
Again, composite templates are described by <code>xml</code> files.</p>
<p><span class="filename">Filename: listings/interface_builder/3/window/window.ui</span></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;interface&gt;
  &lt;template class=&quot;MyGtkAppWindow&quot; parent=&quot;GtkApplicationWindow&quot;&gt;
    &lt;property name=&quot;title&quot;&gt;My GTK App&lt;/property&gt;
    &lt;child&gt;
      &lt;object class=&quot;MyGtkAppCustomButton&quot; id=&quot;button&quot;&gt;
        &lt;property name=&quot;label&quot;&gt;Press me!&lt;/property&gt;
        &lt;property name=&quot;margin-top&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-bottom&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-start&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-end&quot;&gt;12&lt;/property&gt;  
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/template&gt;
&lt;/interface&gt;
</code></pre>
<p>At first glance, the content seems to be nearly the same.
Before, we described a pre-existing widget.</p>
<pre><code class="language-xml">&lt;object class=&quot;GtkApplicationWindow&quot; id=&quot;window&quot;&gt;
</code></pre>
<p>Now, we create a custom widget and let it inherit from a pre-existing one.</p>
<pre><code class="language-xml">&lt;template class=&quot;MyGtkAppWindow&quot; parent=&quot;GtkApplicationWindow&quot;&gt;
</code></pre>
<p>Within our code we create a custom widget inheriting from <code>gtk::ApplicationWindow</code> to make use of our template.</p>
<p><span class="filename">Filename: listings/interface_builder/3/window/mod.rs</span></p>
<pre><code class="language-rust  no_run noplayground">mod imp;

use glib::Object;
use gtk::Application;
use gtk::{gio, glib};

glib::wrapper! {
    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
}

impl Window {
    pub fn new(app: &amp;Application) -&gt; Self {
        // Create new window
        Object::new(&amp;[(&quot;application&quot;, app)]).expect(&quot;Failed to create Window&quot;)
    }
}</code></pre>
<p>In the private struct, we then add the derive macro <code>gtk::CompositeTemplate</code>.
We also specify that the template information comes from a file <code>window.ui</code> in the same folder.</p>
<p><span class="filename">Filename: listings/interface_builder/3/window/imp.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::CompositeTemplate;
</span><span class="boring">
</span><span class="boring">use crate::custom_button::CustomButton;
</span><span class="boring">
</span>// Object holding the state
#[derive(CompositeTemplate, Default)]
#[template(file = &quot;window.ui&quot;)]
pub struct Window {
    #[template_child]
    pub button: TemplateChild&lt;CustomButton&gt;,
}
<span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = &quot;MyGtkAppWindow&quot;;
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = gtk::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self, obj: &amp;Self::Type) {
</span><span class="boring">        // Call &quot;constructed&quot; on parent
</span><span class="boring">        self.parent_constructed(obj);
</span><span class="boring">
</span><span class="boring">        // Connect to &quot;clicked&quot; signal of `button`
</span><span class="boring">        self.button.connect_clicked(move |button| {
</span><span class="boring">            // Set the label to &quot;Hello World!&quot; after the button has been clicked on
</span><span class="boring">            button.set_label(&quot;Hello World!&quot;);
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<p>One very convenient feature of templates is the template child.
You use it by adding a struct member with the same name as one <code>id</code> attribute in the template.
Template child then:</p>
<ul>
<li>assures that the widget gets registered without doing it manually in <code>main.rs</code>, and</li>
<li>stores a reference to the widget for later use.</li>
</ul>
<p>We need both for our custom button, so we add it to the struct.</p>
<p><span class="filename">Filename: listings/interface_builder/3/window/imp.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::CompositeTemplate;
</span><span class="boring">
</span><span class="boring">use crate::custom_button::CustomButton;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(file = &quot;window.ui&quot;)]
</span><span class="boring">pub struct Window {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub button: TemplateChild&lt;CustomButton&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for Window {
    // `NAME` needs to match `class` attribute of template
    const NAME: &amp;'static str = &quot;MyGtkAppWindow&quot;;
    type Type = super::Window;
    type ParentType = gtk::ApplicationWindow;

    fn class_init(klass: &amp;mut Self::Class) {
        klass.bind_template();
    }

    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
        obj.init_template();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self, obj: &amp;Self::Type) {
</span><span class="boring">        // Call &quot;constructed&quot; on parent
</span><span class="boring">        self.parent_constructed(obj);
</span><span class="boring">
</span><span class="boring">        // Connect to &quot;clicked&quot; signal of `button`
</span><span class="boring">        self.button.connect_clicked(move |button| {
</span><span class="boring">            // Set the label to &quot;Hello World!&quot; after the button has been clicked on
</span><span class="boring">            button.set_label(&quot;Hello World!&quot;);
</span><span class="boring">        });
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<p>Within the <code>ObjectSubclass</code> trait, we make sure that <code>NAME</code> corresponds to <code>class</code> in the template and <code>ParentType</code> corresponds to <code>parent</code> in the template.
We also bind and initialize the template in <code>class_init</code> and <code>instance_init</code>.</p>
<p><span class="filename">Filename: listings/interface_builder/3/window/imp.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::CompositeTemplate;
</span><span class="boring">
</span><span class="boring">use crate::custom_button::CustomButton;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(file = &quot;window.ui&quot;)]
</span><span class="boring">pub struct Window {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub button: TemplateChild&lt;CustomButton&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = &quot;MyGtkAppWindow&quot;;
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = gtk::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// Trait shared by all GObjects
impl ObjectImpl for Window {
    fn constructed(&amp;self, obj: &amp;Self::Type) {
        // Call &quot;constructed&quot; on parent
        self.parent_constructed(obj);

        // Connect to &quot;clicked&quot; signal of `button`
        self.button.connect_clicked(move |button| {
            // Set the label to &quot;Hello World!&quot; after the button has been clicked on
            button.set_label(&quot;Hello World!&quot;);
        });
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<p>Finally, we connect the callback to the &quot;clicked&quot; signal of <code>button</code> within <code>constructed</code>.
The button is easily available thanks to the stored reference in <code>self</code>.</p>
<p><span class="filename">Filename: listings/interface_builder/3/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">pub mod custom_button;
</span><span class="boring">mod window;
</span><span class="boring">
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::Application;
</span><span class="boring">
</span><span class="boring">use window::Window;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Create a new application
</span><span class="boring">    let app = Application::builder()
</span><span class="boring">        .application_id(&quot;org.gtk-rs.example&quot;)
</span><span class="boring">        .build();
</span><span class="boring">
</span><span class="boring">    // Connect to &quot;activate&quot; signal of `app`
</span><span class="boring">    app.connect_activate(build_ui);
</span><span class="boring">
</span><span class="boring">    // Run the application
</span><span class="boring">    app.run();
</span><span class="boring">}
</span><span class="boring">
</span>fn build_ui(app: &amp;Application) {
    // Create new window and present it
    let window = Window::new(app);
    window.present();
}</code></pre>
<p>With composite templates, <code>main.rs</code> actually became more concise.
With regard to capabilities, we also get the best of both worlds.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>Thanks to custom widgets we can</p>
<ul>
<li>keep state and part of it as properties,</li>
<li>add signals as well as</li>
<li>override behavior.</li>
</ul>
<p>Thanks to composite templates we can</p>
<ul>
<li>describe complex user interfaces concisely, and</li>
<li>easily access widgets within the template. </li>
</ul>
<p>The API of the interface builder is extensive so especially at the beginning you will want to check out the documentation.
The basic syntax is explained with <a href="../docs/gtk4/struct.Builder.html#gtkbuilder-ui-definitions"><code>Builder</code></a>, syntax specific to widgets with <a href="../docs/gtk4/struct.Widget.html#gtkwidget-as-gtkbuildable"><code>Widget</code></a>.
If a certain widget accepts additional element, then they are typically explained in the docs of the widget.</p>
<p>In the following chapter, we will see how composite templates help us to create slightly bigger apps such as a To-Do app.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="list_widgets.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="todo_app_1.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="list_widgets.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="todo_app_1.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
