<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Building a Simple To-Do App - GUI development with Rust and GTK 4</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">1.</strong> Installation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="installation_linux.html"><strong aria-hidden="true">1.1.</strong> Linux</a></li><li class="chapter-item expanded "><a href="installation_macos.html"><strong aria-hidden="true">1.2.</strong> macOS</a></li><li class="chapter-item expanded "><a href="installation_windows.html"><strong aria-hidden="true">1.3.</strong> Windows</a></li></ol></li><li class="chapter-item expanded "><a href="project_setup.html"><strong aria-hidden="true">2.</strong> Project Setup</a></li><li class="chapter-item expanded "><a href="hello_world.html"><strong aria-hidden="true">3.</strong> Hello World!</a></li><li class="chapter-item expanded "><a href="widgets.html"><strong aria-hidden="true">4.</strong> Widgets</a></li><li class="chapter-item expanded "><a href="gobject_concepts.html"><strong aria-hidden="true">5.</strong> GObject Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="gobject_memory_management.html"><strong aria-hidden="true">5.1.</strong> Memory Management</a></li><li class="chapter-item expanded "><a href="gobject_subclassing.html"><strong aria-hidden="true">5.2.</strong> Subclassing</a></li><li class="chapter-item expanded "><a href="gobject_values.html"><strong aria-hidden="true">5.3.</strong> Generic Values</a></li><li class="chapter-item expanded "><a href="gobject_properties.html"><strong aria-hidden="true">5.4.</strong> Properties</a></li><li class="chapter-item expanded "><a href="gobject_signals.html"><strong aria-hidden="true">5.5.</strong> Signals</a></li></ol></li><li class="chapter-item expanded "><a href="main_event_loop.html"><strong aria-hidden="true">6.</strong> The Main Event Loop</a></li><li class="chapter-item expanded "><a href="settings.html"><strong aria-hidden="true">7.</strong> Settings</a></li><li class="chapter-item expanded "><a href="saving_window_state.html"><strong aria-hidden="true">8.</strong> Saving Window State</a></li><li class="chapter-item expanded "><a href="list_widgets.html"><strong aria-hidden="true">9.</strong> List Widgets</a></li><li class="chapter-item expanded "><a href="interface_builder.html"><strong aria-hidden="true">10.</strong> Interface Builder</a></li><li class="chapter-item expanded "><a href="todo_app_1.html" class="active"><strong aria-hidden="true">11.</strong> Building a Simple To-Do App</a></li><li class="chapter-item expanded "><a href="actions.html"><strong aria-hidden="true">12.</strong> Actions</a></li><li class="chapter-item expanded "><a href="todo_app_2.html"><strong aria-hidden="true">13.</strong> Manipulating State of To-Do App</a></li><li class="chapter-item expanded "><a href="css.html"><strong aria-hidden="true">14.</strong> CSS</a></li><li class="chapter-item expanded "><a href="resources.html"><strong aria-hidden="true">15.</strong> Resources</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.</strong> Internationalization</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">17.</strong> Accessibility</div></li><li class="chapter-item expanded affix "><li class="part-title">Useful Libraries</li><li class="chapter-item expanded "><div><strong aria-hidden="true">18.</strong> Relm4</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">19.</strong> GStreamer</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">20.</strong> Adwaita</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">21.</strong> SourceView</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">22.</strong> Shumate</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">23.</strong> WebKitGTK</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">24.</strong> Zbus and Ashpd</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">25.</strong> Librsvg</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">GUI development with Rust and GTK 4</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/gtk-rs/gtk4-rs/tree/master/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="building-a-simple-to-do-app"><a class="header" href="#building-a-simple-to-do-app">Building a Simple To-Do App</a></h1>
<p>After we have learned so many concepts, it is finally time to put them into practice.
We are going to build a To-Do app!</p>
<p>For now, we would already be satisfied with a minimal version.
An entry to input new tasks and a list view to display them will suffice.
Something like this:</p>
<div style="text-align:center"><img src="img/todo_app_1_mockup.png" /></div>
<h2 id="window"><a class="header" href="#window">Window</a></h2>
<p>This mockup can be described by the following composite template.</p>
<p><span class="filename">Filename: listings/todo_app/1/window/window.ui</span></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;interface&gt;
  &lt;template class=&quot;TodoWindow&quot; parent=&quot;GtkApplicationWindow&quot;&gt;
    &lt;property name=&quot;width-request&quot;&gt;360&lt;/property&gt;
    &lt;property name=&quot;title&quot; translatable=&quot;yes&quot;&gt;To-Do&lt;/property&gt;
    &lt;child&gt;
      &lt;object class=&quot;GtkBox&quot;&gt;
        &lt;property name=&quot;orientation&quot;&gt;vertical&lt;/property&gt;
        &lt;property name=&quot;margin-top&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-bottom&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-start&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-end&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;spacing&quot;&gt;6&lt;/property&gt;
        &lt;child&gt;
          &lt;object class=&quot;GtkEntry&quot; id=&quot;entry&quot;/&gt;
        &lt;/child&gt;
        &lt;child&gt;
          &lt;object class=&quot;GtkScrolledWindow&quot;&gt;
            &lt;property name=&quot;hscrollbar-policy&quot;&gt;never&lt;/property&gt;
            &lt;property name=&quot;min-content-height&quot;&gt;360&lt;/property&gt;
            &lt;property name=&quot;vexpand&quot;&gt;true&lt;/property&gt;
            &lt;child&gt;
              &lt;object class=&quot;GtkListView&quot; id=&quot;list_view&quot;/&gt;
            &lt;/child&gt;
          &lt;/object&gt;
        &lt;/child&gt;
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/template&gt;
&lt;/interface&gt;
</code></pre>
<p>In order to use the composite template, we create a custom widget.
The <code>parent</code> is <code>gtk::ApplicationWindow</code>, so we inherit from it.
As usual, we have to list all <a href="https://docs.gtk.org/gtk4/class.ApplicationWindow.html#ancestors">ancestors</a> and <a href="https://docs.gtk.org/gtk4/class.ApplicationWindow.html#implements">interfaces</a> apart from <code>GObject</code> and <code>GInitiallyUnowned</code>.</p>
<p><span class="filename">Filename: listings/todo_app/1/window/mod.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use crate::todo_object::TodoObject;
</span><span class="boring">use crate::todo_row::TodoRow;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use gtk::{Application, NoSelection, SignalListItemFactory};
</span><span class="boring">
</span>glib::wrapper! {
    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
}
<span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::new(&amp;[(&quot;application&quot;, app)]).expect(&quot;Failed to create `Window`.&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn model(&amp;self) -&gt; &amp;gio::ListStore {
</span><span class="boring">        // Get state
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        imp.model.get().expect(&quot;Could not get model&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_model(&amp;self) {
</span><span class="boring">        // Create new model
</span><span class="boring">        let model = gio::ListStore::new(TodoObject::static_type());
</span><span class="boring">
</span><span class="boring">        // Get state and set model
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        imp.model.set(model).expect(&quot;Could not set model&quot;);
</span><span class="boring">
</span><span class="boring">        // Wrap model with selection and pass it to the list view
</span><span class="boring">        let selection_model = NoSelection::new(Some(self.model()));
</span><span class="boring">        imp.list_view.set_model(Some(&amp;selection_model));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Get state
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        let model = self.model();
</span><span class="boring">
</span><span class="boring">        // Setup callback so that activation
</span><span class="boring">        // creates a new todo object and clears the entry
</span><span class="boring">        imp.entry
</span><span class="boring">            .connect_activate(clone!(@weak model =&gt; move |entry| {
</span><span class="boring">                let buffer = entry.buffer();
</span><span class="boring">                let content = buffer.text();
</span><span class="boring">                let todo_object = TodoObject::new(false, content);
</span><span class="boring">                model.append(&amp;todo_object);
</span><span class="boring">                buffer.set_text(&quot;&quot;);
</span><span class="boring">            }));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_factory(&amp;self) {
</span><span class="boring">        // Create a new factory
</span><span class="boring">        let factory = SignalListItemFactory::new();
</span><span class="boring">
</span><span class="boring">        // Create an empty `TodoRow` during setup
</span><span class="boring">        factory.connect_setup(move |_, list_item| {
</span><span class="boring">            // Create `TodoRow`
</span><span class="boring">            let todo_row = TodoRow::new();
</span><span class="boring">            list_item.set_child(Some(&amp;todo_row));
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to bind `TodoRow` to a `TodoObject`
</span><span class="boring">        factory.connect_bind(move |_, list_item| {
</span><span class="boring">            // Get `TodoObject` from `ListItem`
</span><span class="boring">            let todo_object = list_item
</span><span class="boring">                .item()
</span><span class="boring">                .expect(&quot;The item has to exist.&quot;)
</span><span class="boring">                .downcast::&lt;TodoObject&gt;()
</span><span class="boring">                .expect(&quot;The item has to be an `TodoObject`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Get `TodoRow` from `ListItem`
</span><span class="boring">            let todo_row = list_item
</span><span class="boring">                .child()
</span><span class="boring">                .expect(&quot;The child has to exist.&quot;)
</span><span class="boring">                .downcast::&lt;TodoRow&gt;()
</span><span class="boring">                .expect(&quot;The child has to be a `TodoRow`.&quot;);
</span><span class="boring">
</span><span class="boring">            todo_row.bind(&amp;todo_object);
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to unbind `TodoRow` from `TodoObject`
</span><span class="boring">        factory.connect_unbind(move |_, list_item| {
</span><span class="boring">            // Get `TodoRow` from `ListItem`
</span><span class="boring">            let todo_row = list_item
</span><span class="boring">                .child()
</span><span class="boring">                .expect(&quot;The child has to exist.&quot;)
</span><span class="boring">                .downcast::&lt;TodoRow&gt;()
</span><span class="boring">                .expect(&quot;The child has to be a `TodoRow`.&quot;);
</span><span class="boring">
</span><span class="boring">            todo_row.unbind();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Set the factory of the list view
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        imp.list_view.set_factory(Some(&amp;factory));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Then we initialize the composite template for <code>imp::Window</code>.
We store references to the entry, the list view as well as the list model.
This will come in handy when we later add methods to our window.
After that, we add the typical boilerplate for initializing composite templates.
We only have to assure that the <code>class</code> attribute of the template in <code>window.ui</code> matches <code>NAME</code>.</p>
<p><span class="filename">Filename: listings/todo_app/1/window/imp.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use gtk::{CompositeTemplate, Entry, ListView};
</span><span class="boring">use once_cell::sync::OnceCell;
</span><span class="boring">
</span>// Object holding the state
#[derive(CompositeTemplate, Default)]
#[template(file = &quot;window.ui&quot;)]
pub struct Window {
    #[template_child]
    pub entry: TemplateChild&lt;Entry&gt;,
    #[template_child]
    pub list_view: TemplateChild&lt;ListView&gt;,
    pub model: OnceCell&lt;gio::ListStore&gt;,
}

// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for Window {
    // `NAME` needs to match `class` attribute of template
    const NAME: &amp;'static str = &quot;TodoWindow&quot;;
    type Type = super::Window;
    type ParentType = gtk::ApplicationWindow;

    fn class_init(klass: &amp;mut Self::Class) {
        klass.bind_template();
    }

    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
        obj.init_template();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for Window {
</span><span class="boring">    fn constructed(&amp;self, obj: &amp;Self::Type) {
</span><span class="boring">        // Call &quot;constructed&quot; on parent
</span><span class="boring">        self.parent_constructed(obj);
</span><span class="boring">
</span><span class="boring">        // Setup
</span><span class="boring">        obj.setup_model();
</span><span class="boring">        obj.setup_callbacks();
</span><span class="boring">        obj.setup_factory();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<p><code>main.rs</code> also does not hold any surprises for us.</p>
<p><span class="filename">Filename: listings/todo_app/1/main.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod todo_object;
</span><span class="boring">mod todo_row;
</span><span class="boring">mod window;
</span><span class="boring">
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::Application;
</span><span class="boring">
</span><span class="boring">use window::Window;
</span><span class="boring">
</span>fn main() {
    // Initialize logger
    pretty_env_logger::init();

    // Create a new application
    let app = Application::builder()
        .application_id(&quot;org.gtk-rs.Todo&quot;)
        .build();

    // Connect to &quot;activate&quot; signal of `app`
    app.connect_activate(build_ui);

    // Run the application
    app.run();
}

fn build_ui(app: &amp;Application) {
    // Create a new custom window and show it
    let window = Window::new(app);
    window.present();
}</code></pre>
<h2 id="to-do-object"><a class="header" href="#to-do-object">To-Do Object</a></h2>
<p>So far so good.
The main user interface is done, but the entry does not react to input yet.
Also, where would the input go?
We have not even set up the list model yet.
Let us do that!</p>
<div style="text-align:center"><img src="img/todo_app_1_empty.png" /></div>
<p>As discussed in the <a href="./list_widgets.html">list widgets chapter</a>,
we start out by creating a custom GObject.
This object will store the state of the task consisting of:</p>
<ul>
<li>a boolean describing whether the task is completed or not, and</li>
<li>a string holding the task name.</li>
</ul>
<p><span class="filename">Filename: listings/todo_app/1/todo_object/mod.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::glib;
</span><span class="boring">
</span>glib::wrapper! {
    pub struct TodoObject(ObjectSubclass&lt;imp::TodoObject&gt;);
}

impl TodoObject {
    pub fn new(completed: bool, content: String) -&gt; Self {
        Object::new(&amp;[(&quot;completed&quot;, &amp;completed), (&quot;content&quot;, &amp;content)])
            .expect(&quot;Failed to create `TodoObject`.&quot;)
    }
}
<span class="boring">
</span><span class="boring">#[derive(Default)]
</span><span class="boring">pub struct TodoData {
</span><span class="boring">    pub completed: bool,
</span><span class="boring">    pub content: String,
</span><span class="boring">}</span></code></pre>
<p>Unlike the lists chapter, the state is stored in a struct rather than in individual members of <code>imp::TodoObject</code>.
This will be very convenient when saving the state in one of the following chapters.</p>
<p><span class="filename">Filename: listings/todo_app/1/todo_object/mod.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use glib::Object;
</span><span class="boring">use gtk::glib;
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct TodoObject(ObjectSubclass&lt;imp::TodoObject&gt;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TodoObject {
</span><span class="boring">    pub fn new(completed: bool, content: String) -&gt; Self {
</span><span class="boring">        Object::new(&amp;[(&quot;completed&quot;, &amp;completed), (&quot;content&quot;, &amp;content)])
</span><span class="boring">            .expect(&quot;Failed to create `TodoObject`.&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(Default)]
pub struct TodoData {
    pub completed: bool,
    pub content: String,
}</code></pre>
<p>Exposing <code>completed</code> and <code>content</code> as properties does not become much different that way, so we will not discuss it further.
If you are curious, you can press on the small eye symbol on the top right of the code snippet to read the implementation.</p>
<p><span class="filename">Filename: listings/todo_app/1/todo_object/imp.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use glib::{ParamFlags, ParamSpec, ParamSpecBoolean, ParamSpecString, Value};
</span><span class="boring">use gtk::glib;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">
</span><span class="boring">use once_cell::sync::Lazy;
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span><span class="boring">use super::TodoData;
</span><span class="boring">
</span>// Object holding the state
#[derive(Default)]
pub struct TodoObject {
    pub data: Rc&lt;RefCell&lt;TodoData&gt;&gt;,
}

// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for TodoObject {
    const NAME: &amp;'static str = &quot;TodoObject&quot;;
    type Type = super::TodoObject;
}
<span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for TodoObject {
</span><span class="boring">    fn properties() -&gt; &amp;'static [ParamSpec] {
</span><span class="boring">        static PROPERTIES: Lazy&lt;Vec&lt;ParamSpec&gt;&gt; = Lazy::new(|| {
</span><span class="boring">            vec![
</span><span class="boring">                ParamSpecBoolean::new(
</span><span class="boring">                    // Name
</span><span class="boring">                    &quot;completed&quot;,
</span><span class="boring">                    // Nickname
</span><span class="boring">                    &quot;completed&quot;,
</span><span class="boring">                    // Short description
</span><span class="boring">                    &quot;completed&quot;,
</span><span class="boring">                    // Default value
</span><span class="boring">                    false,
</span><span class="boring">                    // The property can be read and written to
</span><span class="boring">                    ParamFlags::READWRITE,
</span><span class="boring">                ),
</span><span class="boring">                ParamSpecString::new(
</span><span class="boring">                    // Name
</span><span class="boring">                    &quot;content&quot;,
</span><span class="boring">                    // Nickname
</span><span class="boring">                    &quot;content&quot;,
</span><span class="boring">                    // Short description
</span><span class="boring">                    &quot;content&quot;,
</span><span class="boring">                    // Default value
</span><span class="boring">                    None,
</span><span class="boring">                    // The property can be read and written to
</span><span class="boring">                    ParamFlags::READWRITE,
</span><span class="boring">                ),
</span><span class="boring">            ]
</span><span class="boring">        });
</span><span class="boring">        PROPERTIES.as_ref()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_property(&amp;self, _obj: &amp;Self::Type, _id: usize, value: &amp;Value, pspec: &amp;ParamSpec) {
</span><span class="boring">        match pspec.name() {
</span><span class="boring">            &quot;completed&quot; =&gt; {
</span><span class="boring">                let input_value = value.get().expect(&quot;The value needs to be of type `bool`.&quot;);
</span><span class="boring">                self.data.borrow_mut().completed = input_value;
</span><span class="boring">            }
</span><span class="boring">            &quot;content&quot; =&gt; {
</span><span class="boring">                let input_value = value
</span><span class="boring">                    .get()
</span><span class="boring">                    .expect(&quot;The value needs to be of type `String`.&quot;);
</span><span class="boring">                self.data.borrow_mut().content = input_value;
</span><span class="boring">            }
</span><span class="boring">            _ =&gt; unimplemented!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn property(&amp;self, _obj: &amp;Self::Type, _id: usize, pspec: &amp;ParamSpec) -&gt; Value {
</span><span class="boring">        match pspec.name() {
</span><span class="boring">            &quot;completed&quot; =&gt; self.data.borrow().completed.to_value(),
</span><span class="boring">            &quot;content&quot; =&gt; self.data.borrow().content.to_value(),
</span><span class="boring">            _ =&gt; unimplemented!(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<h2 id="to-do-row"><a class="header" href="#to-do-row">To-Do Row</a></h2>
<p>Let us move on to the individual tasks.
The row of a task should look like this:</p>
<div style="text-align:center"><img src="img/todo_row.png" /></div>
<p>Again, we describe the mockup with a composite template.</p>
<p><span class="filename">Filename: listings/todo_app/1/todo_row/todo_row.ui</span></p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;interface&gt;
  &lt;template class=&quot;TodoRow&quot; parent=&quot;GtkBox&quot;&gt;
    &lt;child&gt;
      &lt;object class=&quot;GtkCheckButton&quot; id=&quot;completed_button&quot;&gt;
        &lt;property name=&quot;margin-top&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-bottom&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-start&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-end&quot;&gt;12&lt;/property&gt;
      &lt;/object&gt;
    &lt;/child&gt;
    &lt;child&gt;
      &lt;object class=&quot;GtkLabel&quot; id=&quot;content_label&quot;&gt;
        &lt;property name=&quot;margin-top&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-bottom&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-start&quot;&gt;12&lt;/property&gt;
        &lt;property name=&quot;margin-end&quot;&gt;12&lt;/property&gt;
      &lt;/object&gt;
    &lt;/child&gt;
  &lt;/template&gt;
&lt;/interface&gt;
</code></pre>
<p>In the code, we <a href="https://docs.gtk.org/gtk4/class.Box.html#hierarchy">derive</a> <code>TodoRow</code> from <code>gtk:Box</code>:</p>
<p><span class="filename">Filename: listings/todo_app/1/todo_row/mod.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use crate::todo_object::TodoObject;
</span><span class="boring">use glib::{BindingFlags, Object};
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{glib, pango};
</span><span class="boring">use pango::{AttrInt, AttrList};
</span><span class="boring">
</span>glib::wrapper! {
    pub struct TodoRow(ObjectSubclass&lt;imp::TodoRow&gt;)
    @extends gtk::Box, gtk::Widget,
    @implements gtk::Accessible, gtk::Buildable, gtk::ConstraintTarget, gtk::Orientable;
}
<span class="boring">
</span><span class="boring">impl Default for TodoRow {
</span><span class="boring">    fn default() -&gt; Self {
</span><span class="boring">        Self::new()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TodoRow {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        Object::new(&amp;[]).expect(&quot;Failed to create `TodoRow`.&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn bind(&amp;self, todo_object: &amp;TodoObject) {
</span><span class="boring">        // Get state
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        let completed_button = imp.completed_button.get();
</span><span class="boring">        let content_label = imp.content_label.get();
</span><span class="boring">        let mut bindings = imp.bindings.borrow_mut();
</span><span class="boring">
</span><span class="boring">        // Bind `todo_object.completed` to `todo_row.completed_button.active`
</span><span class="boring">        let completed_button_binding = todo_object
</span><span class="boring">            .bind_property(&quot;completed&quot;, &amp;completed_button, &quot;active&quot;)
</span><span class="boring">            .flags(BindingFlags::SYNC_CREATE | BindingFlags::BIDIRECTIONAL)
</span><span class="boring">            .build();
</span><span class="boring">        // Save binding
</span><span class="boring">        bindings.push(completed_button_binding);
</span><span class="boring">
</span><span class="boring">        // Bind `todo_object.content` to `todo_row.content_label.label`
</span><span class="boring">        let content_label_binding = todo_object
</span><span class="boring">            .bind_property(&quot;content&quot;, &amp;content_label, &quot;label&quot;)
</span><span class="boring">            .flags(BindingFlags::SYNC_CREATE)
</span><span class="boring">            .build();
</span><span class="boring">        // Save binding
</span><span class="boring">        bindings.push(content_label_binding);
</span><span class="boring">
</span><span class="boring">        // Bind `todo_object.completed` to `todo_row.content_label.attributes`
</span><span class="boring">        let content_label_binding = todo_object
</span><span class="boring">            .bind_property(&quot;completed&quot;, &amp;content_label, &quot;attributes&quot;)
</span><span class="boring">            .flags(BindingFlags::SYNC_CREATE)
</span><span class="boring">            .transform_to(|_, active_value| {
</span><span class="boring">                let attribute_list = AttrList::new();
</span><span class="boring">                let active = active_value
</span><span class="boring">                    .get::&lt;bool&gt;()
</span><span class="boring">                    .expect(&quot;The value needs to be of type `bool`.&quot;);
</span><span class="boring">                if active {
</span><span class="boring">                    // If &quot;active&quot; is true, content of the label will be strikethrough
</span><span class="boring">                    let attribute = AttrInt::new_strikethrough(true);
</span><span class="boring">                    attribute_list.insert(attribute);
</span><span class="boring">                }
</span><span class="boring">                Some(attribute_list.to_value())
</span><span class="boring">            })
</span><span class="boring">            .build();
</span><span class="boring">        // Save binding
</span><span class="boring">        bindings.push(content_label_binding);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn unbind(&amp;self) {
</span><span class="boring">        // Get state
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">
</span><span class="boring">        // Unbind all stored bindings
</span><span class="boring">        for binding in imp.bindings.borrow_mut().drain(..) {
</span><span class="boring">            binding.unbind();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>In <code>imp::TodoRow</code>, we hold references to <code>completed_button</code> and <code>content_label</code>.
We also store a mutable vector of bindings.
Why we need that will become clear as soon as we get to bind the state of <code>TodoObject</code> to the corresponding <code>TodoRow</code>.</p>
<p><span class="filename">Filename: listings/todo_app/1/todo_row/imp.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use glib::Binding;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{glib, CheckButton, CompositeTemplate, Label};
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">
</span>// Object holding the state
#[derive(Default, CompositeTemplate)]
#[template(file = &quot;todo_row.ui&quot;)]
pub struct TodoRow {
    #[template_child]
    pub completed_button: TemplateChild&lt;CheckButton&gt;,
    #[template_child]
    pub content_label: TemplateChild&lt;Label&gt;,
    // Vector holding the bindings to properties of `TodoObject`
    pub bindings: RefCell&lt;Vec&lt;Binding&gt;&gt;,
}

// The central trait for subclassing a GObject
#[glib::object_subclass]
impl ObjectSubclass for TodoRow {
    // `NAME` needs to match `class` attribute of template
    const NAME: &amp;'static str = &quot;TodoRow&quot;;
    type Type = super::TodoRow;
    type ParentType = gtk::Box;

    fn class_init(klass: &amp;mut Self::Class) {
        klass.bind_template();
    }

    fn instance_init(obj: &amp;glib::subclass::InitializingObject&lt;Self&gt;) {
        obj.init_template();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all GObjects
</span><span class="boring">impl ObjectImpl for TodoRow {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for TodoRow {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all boxes
</span><span class="boring">impl BoxImpl for TodoRow {}</span></code></pre>
<p>Now we can bring everything together.
We override the <code>imp::Window::constructed</code> in order to set up window contents at the time of its construction.</p>
<p><span class="filename">Filename: listings/todo_app/1/window/imp.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">use glib::subclass::InitializingObject;
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use gtk::{CompositeTemplate, Entry, ListView};
</span><span class="boring">use once_cell::sync::OnceCell;
</span><span class="boring">
</span><span class="boring">// Object holding the state
</span><span class="boring">#[derive(CompositeTemplate, Default)]
</span><span class="boring">#[template(file = &quot;window.ui&quot;)]
</span><span class="boring">pub struct Window {
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub entry: TemplateChild&lt;Entry&gt;,
</span><span class="boring">    #[template_child]
</span><span class="boring">    pub list_view: TemplateChild&lt;ListView&gt;,
</span><span class="boring">    pub model: OnceCell&lt;gio::ListStore&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// The central trait for subclassing a GObject
</span><span class="boring">#[glib::object_subclass]
</span><span class="boring">impl ObjectSubclass for Window {
</span><span class="boring">    // `NAME` needs to match `class` attribute of template
</span><span class="boring">    const NAME: &amp;'static str = &quot;TodoWindow&quot;;
</span><span class="boring">    type Type = super::Window;
</span><span class="boring">    type ParentType = gtk::ApplicationWindow;
</span><span class="boring">
</span><span class="boring">    fn class_init(klass: &amp;mut Self::Class) {
</span><span class="boring">        klass.bind_template();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn instance_init(obj: &amp;InitializingObject&lt;Self&gt;) {
</span><span class="boring">        obj.init_template();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// Trait shared by all GObjects
impl ObjectImpl for Window {
    fn constructed(&amp;self, obj: &amp;Self::Type) {
        // Call &quot;constructed&quot; on parent
        self.parent_constructed(obj);

        // Setup
        obj.setup_model();
        obj.setup_callbacks();
        obj.setup_factory();
    }
}
<span class="boring">
</span><span class="boring">// Trait shared by all widgets
</span><span class="boring">impl WidgetImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all windows
</span><span class="boring">impl WindowImpl for Window {}
</span><span class="boring">
</span><span class="boring">// Trait shared by all application
</span><span class="boring">impl ApplicationWindowImpl for Window {}</span></code></pre>
<p>Since we need to access the list model quite often, we add the convenience method <code>Window::model</code> for that.
In <code>Window::setup_model</code> we create a new model.
Then we store a reference to the model in <code>imp::Window</code> as well as in <code>gtk::ListView</code>.</p>
<p><span class="filename">Filename: listings/todo_app/1/window/mod.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use crate::todo_object::TodoObject;
</span><span class="boring">use crate::todo_row::TodoRow;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use gtk::{Application, NoSelection, SignalListItemFactory};
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::new(&amp;[(&quot;application&quot;, app)]).expect(&quot;Failed to create `Window`.&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span>    fn model(&amp;self) -&gt; &amp;gio::ListStore {
        // Get state
        let imp = self.imp();
        imp.model.get().expect(&quot;Could not get model&quot;)
    }

    fn setup_model(&amp;self) {
        // Create new model
        let model = gio::ListStore::new(TodoObject::static_type());

        // Get state and set model
        let imp = self.imp();
        imp.model.set(model).expect(&quot;Could not set model&quot;);

        // Wrap model with selection and pass it to the list view
        let selection_model = NoSelection::new(Some(self.model()));
        imp.list_view.set_model(Some(&amp;selection_model));
    }
<span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Get state
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        let model = self.model();
</span><span class="boring">
</span><span class="boring">        // Setup callback so that activation
</span><span class="boring">        // creates a new todo object and clears the entry
</span><span class="boring">        imp.entry
</span><span class="boring">            .connect_activate(clone!(@weak model =&gt; move |entry| {
</span><span class="boring">                let buffer = entry.buffer();
</span><span class="boring">                let content = buffer.text();
</span><span class="boring">                let todo_object = TodoObject::new(false, content);
</span><span class="boring">                model.append(&amp;todo_object);
</span><span class="boring">                buffer.set_text(&quot;&quot;);
</span><span class="boring">            }));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_factory(&amp;self) {
</span><span class="boring">        // Create a new factory
</span><span class="boring">        let factory = SignalListItemFactory::new();
</span><span class="boring">
</span><span class="boring">        // Create an empty `TodoRow` during setup
</span><span class="boring">        factory.connect_setup(move |_, list_item| {
</span><span class="boring">            // Create `TodoRow`
</span><span class="boring">            let todo_row = TodoRow::new();
</span><span class="boring">            list_item.set_child(Some(&amp;todo_row));
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to bind `TodoRow` to a `TodoObject`
</span><span class="boring">        factory.connect_bind(move |_, list_item| {
</span><span class="boring">            // Get `TodoObject` from `ListItem`
</span><span class="boring">            let todo_object = list_item
</span><span class="boring">                .item()
</span><span class="boring">                .expect(&quot;The item has to exist.&quot;)
</span><span class="boring">                .downcast::&lt;TodoObject&gt;()
</span><span class="boring">                .expect(&quot;The item has to be an `TodoObject`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Get `TodoRow` from `ListItem`
</span><span class="boring">            let todo_row = list_item
</span><span class="boring">                .child()
</span><span class="boring">                .expect(&quot;The child has to exist.&quot;)
</span><span class="boring">                .downcast::&lt;TodoRow&gt;()
</span><span class="boring">                .expect(&quot;The child has to be a `TodoRow`.&quot;);
</span><span class="boring">
</span><span class="boring">            todo_row.bind(&amp;todo_object);
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to unbind `TodoRow` from `TodoObject`
</span><span class="boring">        factory.connect_unbind(move |_, list_item| {
</span><span class="boring">            // Get `TodoRow` from `ListItem`
</span><span class="boring">            let todo_row = list_item
</span><span class="boring">                .child()
</span><span class="boring">                .expect(&quot;The child has to exist.&quot;)
</span><span class="boring">                .downcast::&lt;TodoRow&gt;()
</span><span class="boring">                .expect(&quot;The child has to be a `TodoRow`.&quot;);
</span><span class="boring">
</span><span class="boring">            todo_row.unbind();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Set the factory of the list view
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        imp.list_view.set_factory(Some(&amp;factory));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>In <code>Window::setup_callbacks</code> we connect to the &quot;activate&quot; signal of the entry.
This signal is triggered when we press the enter key in the entry.
Then a new <code>TodoObject</code> with the content will be created and appended to the model.
Finally, the entry will be cleared.</p>
<p><span class="filename">Filename: listings/todo_app/1/window/mod.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use crate::todo_object::TodoObject;
</span><span class="boring">use crate::todo_row::TodoRow;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use gtk::{Application, NoSelection, SignalListItemFactory};
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::new(&amp;[(&quot;application&quot;, app)]).expect(&quot;Failed to create `Window`.&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn model(&amp;self) -&gt; &amp;gio::ListStore {
</span><span class="boring">        // Get state
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        imp.model.get().expect(&quot;Could not get model&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_model(&amp;self) {
</span><span class="boring">        // Create new model
</span><span class="boring">        let model = gio::ListStore::new(TodoObject::static_type());
</span><span class="boring">
</span><span class="boring">        // Get state and set model
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        imp.model.set(model).expect(&quot;Could not set model&quot;);
</span><span class="boring">
</span><span class="boring">        // Wrap model with selection and pass it to the list view
</span><span class="boring">        let selection_model = NoSelection::new(Some(self.model()));
</span><span class="boring">        imp.list_view.set_model(Some(&amp;selection_model));
</span><span class="boring">    }
</span><span class="boring">
</span>    fn setup_callbacks(&amp;self) {
        // Get state
        let imp = self.imp();
        let model = self.model();

        // Setup callback so that activation
        // creates a new todo object and clears the entry
        imp.entry
            .connect_activate(clone!(@weak model =&gt; move |entry| {
                let buffer = entry.buffer();
                let content = buffer.text();
                let todo_object = TodoObject::new(false, content);
                model.append(&amp;todo_object);
                buffer.set_text(&quot;&quot;);
            }));
    }
<span class="boring">
</span><span class="boring">    fn setup_factory(&amp;self) {
</span><span class="boring">        // Create a new factory
</span><span class="boring">        let factory = SignalListItemFactory::new();
</span><span class="boring">
</span><span class="boring">        // Create an empty `TodoRow` during setup
</span><span class="boring">        factory.connect_setup(move |_, list_item| {
</span><span class="boring">            // Create `TodoRow`
</span><span class="boring">            let todo_row = TodoRow::new();
</span><span class="boring">            list_item.set_child(Some(&amp;todo_row));
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to bind `TodoRow` to a `TodoObject`
</span><span class="boring">        factory.connect_bind(move |_, list_item| {
</span><span class="boring">            // Get `TodoObject` from `ListItem`
</span><span class="boring">            let todo_object = list_item
</span><span class="boring">                .item()
</span><span class="boring">                .expect(&quot;The item has to exist.&quot;)
</span><span class="boring">                .downcast::&lt;TodoObject&gt;()
</span><span class="boring">                .expect(&quot;The item has to be an `TodoObject`.&quot;);
</span><span class="boring">
</span><span class="boring">            // Get `TodoRow` from `ListItem`
</span><span class="boring">            let todo_row = list_item
</span><span class="boring">                .child()
</span><span class="boring">                .expect(&quot;The child has to exist.&quot;)
</span><span class="boring">                .downcast::&lt;TodoRow&gt;()
</span><span class="boring">                .expect(&quot;The child has to be a `TodoRow`.&quot;);
</span><span class="boring">
</span><span class="boring">            todo_row.bind(&amp;todo_object);
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Tell factory how to unbind `TodoRow` from `TodoObject`
</span><span class="boring">        factory.connect_unbind(move |_, list_item| {
</span><span class="boring">            // Get `TodoRow` from `ListItem`
</span><span class="boring">            let todo_row = list_item
</span><span class="boring">                .child()
</span><span class="boring">                .expect(&quot;The child has to exist.&quot;)
</span><span class="boring">                .downcast::&lt;TodoRow&gt;()
</span><span class="boring">                .expect(&quot;The child has to be a `TodoRow`.&quot;);
</span><span class="boring">
</span><span class="boring">            todo_row.unbind();
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        // Set the factory of the list view
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        imp.list_view.set_factory(Some(&amp;factory));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>The list elements for the <code>gtk::ListView</code> are produced by a factory.
Before we move on to the implementation, let us take a step back and think about which behavior we expect here.
<code>content_label</code> of <code>TodoRow</code> should follow <code>content</code> of <code>TodoObject</code>.
We also want <code>completed_button</code> of <code>TodoRow</code> follow <code>completed</code> of <code>TodoObject</code>.
This could be achieved with expressions similar to what we did in the lists chapter.</p>
<p>However, if we toggle the state of <code>completed_button</code> of <code>TodoRow</code>, <code>completed</code> of <code>TodoObject</code> should change too.
Unfortunately, expressions cannot handle bidirectional relationships.
This means we have to use property bindings.
We will need to unbind them manually when they are no longer needed.</p>
<p>We will create empty <code>TodoRow</code> objects in the &quot;setup&quot; step in <code>Window::setup_factory</code> and deal with binding in the &quot;bind&quot; and &quot;unbind&quot; steps.</p>
<p><span class="filename">Filename: listings/todo_app/1/window/mod.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use crate::todo_object::TodoObject;
</span><span class="boring">use crate::todo_row::TodoRow;
</span><span class="boring">use glib::{clone, Object};
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{gio, glib};
</span><span class="boring">use gtk::{Application, NoSelection, SignalListItemFactory};
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct Window(ObjectSubclass&lt;imp::Window&gt;)
</span><span class="boring">        @extends gtk::ApplicationWindow, gtk::Window, gtk::Widget,
</span><span class="boring">        @implements gio::ActionGroup, gio::ActionMap, gtk::Accessible, gtk::Buildable,
</span><span class="boring">                    gtk::ConstraintTarget, gtk::Native, gtk::Root, gtk::ShortcutManager;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Window {
</span><span class="boring">    pub fn new(app: &amp;Application) -&gt; Self {
</span><span class="boring">        // Create new window
</span><span class="boring">        Object::new(&amp;[(&quot;application&quot;, app)]).expect(&quot;Failed to create `Window`.&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn model(&amp;self) -&gt; &amp;gio::ListStore {
</span><span class="boring">        // Get state
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        imp.model.get().expect(&quot;Could not get model&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_model(&amp;self) {
</span><span class="boring">        // Create new model
</span><span class="boring">        let model = gio::ListStore::new(TodoObject::static_type());
</span><span class="boring">
</span><span class="boring">        // Get state and set model
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        imp.model.set(model).expect(&quot;Could not set model&quot;);
</span><span class="boring">
</span><span class="boring">        // Wrap model with selection and pass it to the list view
</span><span class="boring">        let selection_model = NoSelection::new(Some(self.model()));
</span><span class="boring">        imp.list_view.set_model(Some(&amp;selection_model));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn setup_callbacks(&amp;self) {
</span><span class="boring">        // Get state
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        let model = self.model();
</span><span class="boring">
</span><span class="boring">        // Setup callback so that activation
</span><span class="boring">        // creates a new todo object and clears the entry
</span><span class="boring">        imp.entry
</span><span class="boring">            .connect_activate(clone!(@weak model =&gt; move |entry| {
</span><span class="boring">                let buffer = entry.buffer();
</span><span class="boring">                let content = buffer.text();
</span><span class="boring">                let todo_object = TodoObject::new(false, content);
</span><span class="boring">                model.append(&amp;todo_object);
</span><span class="boring">                buffer.set_text(&quot;&quot;);
</span><span class="boring">            }));
</span><span class="boring">    }
</span><span class="boring">
</span>    fn setup_factory(&amp;self) {
        // Create a new factory
        let factory = SignalListItemFactory::new();

        // Create an empty `TodoRow` during setup
        factory.connect_setup(move |_, list_item| {
            // Create `TodoRow`
            let todo_row = TodoRow::new();
            list_item.set_child(Some(&amp;todo_row));
        });

        // Tell factory how to bind `TodoRow` to a `TodoObject`
        factory.connect_bind(move |_, list_item| {
            // Get `TodoObject` from `ListItem`
            let todo_object = list_item
                .item()
                .expect(&quot;The item has to exist.&quot;)
                .downcast::&lt;TodoObject&gt;()
                .expect(&quot;The item has to be an `TodoObject`.&quot;);

            // Get `TodoRow` from `ListItem`
            let todo_row = list_item
                .child()
                .expect(&quot;The child has to exist.&quot;)
                .downcast::&lt;TodoRow&gt;()
                .expect(&quot;The child has to be a `TodoRow`.&quot;);

            todo_row.bind(&amp;todo_object);
        });

        // Tell factory how to unbind `TodoRow` from `TodoObject`
        factory.connect_unbind(move |_, list_item| {
            // Get `TodoRow` from `ListItem`
            let todo_row = list_item
                .child()
                .expect(&quot;The child has to exist.&quot;)
                .downcast::&lt;TodoRow&gt;()
                .expect(&quot;The child has to be a `TodoRow`.&quot;);

            todo_row.unbind();
        });

        // Set the factory of the list view
        let imp = self.imp();
        imp.list_view.set_factory(Some(&amp;factory));
    }
<span class="boring">}</span></code></pre>
<p>Binding properties in <code>TodoRow::bind</code> works just like in former chapters.
The only difference is that we store the bindings in a vector.
This is necessary because a <code>TodoRow</code> will be reused as you scroll through the list.
That means that over time a <code>TodoRow</code> will need to bound to a new <code>TodoObject</code> and has to be unbound from the old one.
Unbinding will only work if it can access the stored <code>glib::Binding</code>.</p>
<p><span class="filename">Filename: listings/todo_app/1/todo_row/mod.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use crate::todo_object::TodoObject;
</span><span class="boring">use glib::{BindingFlags, Object};
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{glib, pango};
</span><span class="boring">use pango::{AttrInt, AttrList};
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct TodoRow(ObjectSubclass&lt;imp::TodoRow&gt;)
</span><span class="boring">    @extends gtk::Box, gtk::Widget,
</span><span class="boring">    @implements gtk::Accessible, gtk::Buildable, gtk::ConstraintTarget, gtk::Orientable;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Default for TodoRow {
</span><span class="boring">    fn default() -&gt; Self {
</span><span class="boring">        Self::new()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TodoRow {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        Object::new(&amp;[]).expect(&quot;Failed to create `TodoRow`.&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn bind(&amp;self, todo_object: &amp;TodoObject) {
        // Get state
        let imp = self.imp();
        let completed_button = imp.completed_button.get();
        let content_label = imp.content_label.get();
        let mut bindings = imp.bindings.borrow_mut();

        // Bind `todo_object.completed` to `todo_row.completed_button.active`
        let completed_button_binding = todo_object
            .bind_property(&quot;completed&quot;, &amp;completed_button, &quot;active&quot;)
            .flags(BindingFlags::SYNC_CREATE | BindingFlags::BIDIRECTIONAL)
            .build();
        // Save binding
        bindings.push(completed_button_binding);

        // Bind `todo_object.content` to `todo_row.content_label.label`
        let content_label_binding = todo_object
            .bind_property(&quot;content&quot;, &amp;content_label, &quot;label&quot;)
            .flags(BindingFlags::SYNC_CREATE)
            .build();
        // Save binding
        bindings.push(content_label_binding);

        // Bind `todo_object.completed` to `todo_row.content_label.attributes`
        let content_label_binding = todo_object
            .bind_property(&quot;completed&quot;, &amp;content_label, &quot;attributes&quot;)
            .flags(BindingFlags::SYNC_CREATE)
            .transform_to(|_, active_value| {
                let attribute_list = AttrList::new();
                let active = active_value
                    .get::&lt;bool&gt;()
                    .expect(&quot;The value needs to be of type `bool`.&quot;);
                if active {
                    // If &quot;active&quot; is true, content of the label will be strikethrough
                    let attribute = AttrInt::new_strikethrough(true);
                    attribute_list.insert(attribute);
                }
                Some(attribute_list.to_value())
            })
            .build();
        // Save binding
        bindings.push(content_label_binding);
    }
<span class="boring">
</span><span class="boring">    pub fn unbind(&amp;self) {
</span><span class="boring">        // Get state
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">
</span><span class="boring">        // Unbind all stored bindings
</span><span class="boring">        for binding in imp.bindings.borrow_mut().drain(..) {
</span><span class="boring">            binding.unbind();
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><code>TodoRow::unbind</code> takes care of the cleanup.
It iterates through the vector and unbinds each binding.
In the end, it clears the vector.</p>
<p><span class="filename">Filename: listings/todo_app/1/todo_row/mod.rs</span></p>
<pre><code class="language-rust  no_run noplayground"><span class="boring">mod imp;
</span><span class="boring">
</span><span class="boring">use crate::todo_object::TodoObject;
</span><span class="boring">use glib::{BindingFlags, Object};
</span><span class="boring">use gtk::prelude::*;
</span><span class="boring">use gtk::subclass::prelude::*;
</span><span class="boring">use gtk::{glib, pango};
</span><span class="boring">use pango::{AttrInt, AttrList};
</span><span class="boring">
</span><span class="boring">glib::wrapper! {
</span><span class="boring">    pub struct TodoRow(ObjectSubclass&lt;imp::TodoRow&gt;)
</span><span class="boring">    @extends gtk::Box, gtk::Widget,
</span><span class="boring">    @implements gtk::Accessible, gtk::Buildable, gtk::ConstraintTarget, gtk::Orientable;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Default for TodoRow {
</span><span class="boring">    fn default() -&gt; Self {
</span><span class="boring">        Self::new()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl TodoRow {
</span><span class="boring">    pub fn new() -&gt; Self {
</span><span class="boring">        Object::new(&amp;[]).expect(&quot;Failed to create `TodoRow`.&quot;)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn bind(&amp;self, todo_object: &amp;TodoObject) {
</span><span class="boring">        // Get state
</span><span class="boring">        let imp = self.imp();
</span><span class="boring">        let completed_button = imp.completed_button.get();
</span><span class="boring">        let content_label = imp.content_label.get();
</span><span class="boring">        let mut bindings = imp.bindings.borrow_mut();
</span><span class="boring">
</span><span class="boring">        // Bind `todo_object.completed` to `todo_row.completed_button.active`
</span><span class="boring">        let completed_button_binding = todo_object
</span><span class="boring">            .bind_property(&quot;completed&quot;, &amp;completed_button, &quot;active&quot;)
</span><span class="boring">            .flags(BindingFlags::SYNC_CREATE | BindingFlags::BIDIRECTIONAL)
</span><span class="boring">            .build();
</span><span class="boring">        // Save binding
</span><span class="boring">        bindings.push(completed_button_binding);
</span><span class="boring">
</span><span class="boring">        // Bind `todo_object.content` to `todo_row.content_label.label`
</span><span class="boring">        let content_label_binding = todo_object
</span><span class="boring">            .bind_property(&quot;content&quot;, &amp;content_label, &quot;label&quot;)
</span><span class="boring">            .flags(BindingFlags::SYNC_CREATE)
</span><span class="boring">            .build();
</span><span class="boring">        // Save binding
</span><span class="boring">        bindings.push(content_label_binding);
</span><span class="boring">
</span><span class="boring">        // Bind `todo_object.completed` to `todo_row.content_label.attributes`
</span><span class="boring">        let content_label_binding = todo_object
</span><span class="boring">            .bind_property(&quot;completed&quot;, &amp;content_label, &quot;attributes&quot;)
</span><span class="boring">            .flags(BindingFlags::SYNC_CREATE)
</span><span class="boring">            .transform_to(|_, active_value| {
</span><span class="boring">                let attribute_list = AttrList::new();
</span><span class="boring">                let active = active_value
</span><span class="boring">                    .get::&lt;bool&gt;()
</span><span class="boring">                    .expect(&quot;The value needs to be of type `bool`.&quot;);
</span><span class="boring">                if active {
</span><span class="boring">                    // If &quot;active&quot; is true, content of the label will be strikethrough
</span><span class="boring">                    let attribute = AttrInt::new_strikethrough(true);
</span><span class="boring">                    attribute_list.insert(attribute);
</span><span class="boring">                }
</span><span class="boring">                Some(attribute_list.to_value())
</span><span class="boring">            })
</span><span class="boring">            .build();
</span><span class="boring">        // Save binding
</span><span class="boring">        bindings.push(content_label_binding);
</span><span class="boring">    }
</span><span class="boring">
</span>    pub fn unbind(&amp;self) {
        // Get state
        let imp = self.imp();

        // Unbind all stored bindings
        for binding in imp.bindings.borrow_mut().drain(..) {
            binding.unbind();
        }
    }
<span class="boring">}</span></code></pre>
<p>That was it, we created a basic To-Do app!
We will extend it with additional functionality in the following chapters.</p>
<div style="text-align:center">
 <video autoplay muted loop>
  <source src="vid/todo_app_1_animation.webm" type="video/webm">
Your browser does not support the video tag.
 </video>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="interface_builder.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="actions.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="interface_builder.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="actions.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
